// Copyright 2017 Vladimir Pryahin

/*
 Дано N кубиков. Требуется определить каким количеством способов можно выстроить
 из этих кубиков широкую пирамиду. Каждый вышележащий слой пирамиды 
 должен быть строго меньше нижележащего.
 
 Формат входных данных: На вход подается количество кубиков N.
 Формат выходных данных: Вывести число различных пирамид из N кубиков.
 */

/*==============================================
 Комментарий для преподавателя:
 ===============================================
 Для решения этой задачи я строю таблицу значений. 
 Номер строки(i) означает кол-во кубиков, которое нельзя превышать на нижнем слою.
 Номер столбца(j) означает кол-во неиспользованных кубиков.
 
 Ячейка [i,j] говорит сколько вариантов можно построить с данными параметрами.
 Понятно, что первый столбец заполняется 1(кроме 0 строки)
 
 Данную таблицу нужно заполнять по столбцам, ибо если по строкам, то она некорректно заполнится.
 Чтобы получить значение ячейки [i0,j0] нужно просуммировать значения такой диагонали, у которой:
 1) i+j=j0
 2) i<i0(мы же не можем положить на слой i0 - i0+ кубиков)
 
 Было выведено еще 2 закономерности:
 1) В столбце j0 значения равны предыдущему после того как j0 будет меньше i-1
 2) В строке i0 ненулевые значения принимают только первые i0*(i0-1)/2+1 ячеек(+1 т.к. в таблице еще есть 0 столбец)
 
 Ответом для n кубиков будет ячейка [n+1, n]. Но дабы не заполнять еще 1 строку, ответ можно выразить так:
 ячейка [n,n]+1. (+1 Потому что в ячейка [n,n], в отличие от [n+1,n] не учитывается вариант слой из n кубиков).
 */

#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

//Сумма значений диагонали, такой, что i+j=n и при этом i<width
int64_t sum(int64_t** table, int n, int width) {
    int64_t result = 0;
    
    int i = n >= width ? width - 1 : n, j = n - i;
    while (j < 0) {
        i--;
        j++;
    }
    while (table[i][j] != 0) result += table[i--][j++];
    
    return result;
}

//Главная функция подсчета
int64_t get_count(int count) {
    int64_t** table = new int64_t*[count + 1]();
    
    for (int i = 0; i < count + 1; i++) {
        table[i] = new int64_t[count + 1]();
        table[i][0] = 1;
    }
    table[0][0] = 0;
    
    //заполняем таблицу по столбцам!
    for (int j = 1; j < count + 1; j++) {
        for (int i = 1; i < count + 1; i++) {
            if (j <= i * (i - 1) / 2) {
                if (j + 1 < i)
                    table[i][j] = table[i - 1][j];
                else
                    table[i][j] = sum(table, j, i);
            }
        }
    }
    
    int64_t result = table[count][count] + 1;
    for (int i = 0; i < count + 1; i++) delete[] table[i];
    delete[] table;
    
    return result;
}

int main() {
    int count = 0;
    scanf("%d", &count);
    assert(count >= 0);
    if (count > 0) {
        printf("%lld\n", get_count(count));
    } else {
        printf("0\n");
    }
    return 0;
}
